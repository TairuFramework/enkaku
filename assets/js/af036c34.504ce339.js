"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["2807"],{1906:function(e,n,r){r.r(n),r.d(n,{metadata:()=>t,contentTitle:()=>a,default:()=>h,assets:()=>c,toc:()=>l,frontMatter:()=>i});var t=JSON.parse('{"id":"procedures","title":"Procedures","description":"Procedures are functions handled by a server that can be called by clients.","source":"@site/docs/procedures.mdx","sourceDirName":".","slug":"/procedures","permalink":"/docs/procedures","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Quick start","permalink":"/docs/quick-start"},"next":{"title":"Communications","permalink":"/docs/communications"}}'),s=r("651"),o=r("6537");let i={},a="Procedures",c={},l=[{value:"Defining procedures",id:"defining-procedures",level:2},{value:"Events",id:"events",level:3},{value:"Requests",id:"requests",level:3},{value:"Streams",id:"streams",level:3},{value:"Channels",id:"channels",level:3},{value:"Handling procedures",id:"handling-procedures",level:2},{value:"Defining handlers",id:"defining-handlers",level:3},{value:"Cancellations",id:"cancellations",level:3},{value:"Invoking procedures",id:"invoking-procedures",level:2},{value:"Procedure call state",id:"procedure-call-state",level:3}];function d(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"procedures",children:"Procedures"})}),"\n",(0,s.jsx)(n.p,{children:"Procedures are functions handled by a server that can be called by clients."}),"\n",(0,s.jsx)(n.h2,{id:"defining-procedures",children:"Defining procedures"}),"\n",(0,s.jsxs)(n.p,{children:["Enkaku supports the following four types of procedures: ",(0,s.jsx)(n.a,{href:"#events",children:"events"}),", ",(0,s.jsx)(n.a,{href:"#requests",children:"requests"}),", ",(0,s.jsx)(n.a,{href:"#streams",children:"streams"})," and ",(0,s.jsx)(n.a,{href:"#channels",children:"channels"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Events and requests calls are supported by staless handlers, while streams and channels require stateful handlers to support sending messages from the server to the client."}),"\n",(0,s.jsxs)(n.p,{children:["Defining procedures involves creating a protocol for the client and server, typically using the ",(0,s.jsx)(n.code,{children:"ProtocolDefinition"})," type from the ",(0,s.jsx)(n.code,{children:"@enkaku/protocol"})," package."]}),"\n",(0,s.jsxs)(n.p,{children:["A protocol is defined as a record of procedure names to procedure definitions. Each procedure definition must include the type of procedure (",(0,s.jsx)(n.code,{children:"event"}),", ",(0,s.jsx)(n.code,{children:"request"}),", ",(0,s.jsx)(n.code,{children:"stream"})," or ",(0,s.jsx)(n.code,{children:"channel"}),"), an optional ",(0,s.jsx)(n.code,{children:"description"})," for documentation purposes, and any additional data types required by the procedure."]}),"\n",(0,s.jsx)(n.p,{children:"Procedure names have no particular constraints other than being unique strings within the protocol or set of protocols used on a given transport."}),"\n",(0,s.jsx)(n.p,{children:"Example protocol definition:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nexport const myProtocol = {\n  'myapp:event': {\n    type: 'event',\n    description: 'An example event procedure with no data',\n  },\n  'myapp:request': {\n    type: 'request',\n    description: 'An example request procedure that returns a string',\n    response: { type: 'string' },\n  },\n  'myapp:stream': {\n    type: 'stream',\n    description: 'An example stream procedure that returns a stream of numbers',\n    receive: { type: 'number' },\n  },\n  'myapp:channel': {\n    type: 'channel',\n    description: 'An example channel procedure that sends and receives numbers',\n    send: { type: 'number' },\n    receive: { type: 'number' },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,s.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,s.jsx)(n.p,{children:'Events are simple "fire and forget" calls that the client sends to the server without expecting a response.'}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n  Client->>+Server: Event"}),"\n",(0,s.jsxs)(n.p,{children:["To define an event procedure in Enkaku, the ",(0,s.jsx)(n.code,{children:"type"})," must be set to ",(0,s.jsx)(n.code,{children:"event"}),", for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:event': {\n    type: 'event',\n    description: 'An example event procedure with no data',\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,s.jsx)(n.p,{children:"Events can also have a data object attached to them, which must be defined as a JSON schema in the protocol:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'my:event': {\n    type: 'event',\n    description: 'An example event procedure with data',\n    data: {\n      type: 'object',\n      properties: {\n        value: { type: 'number' },\n      },\n    },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,s.jsx)(n.h3,{id:"requests",children:"Requests"}),"\n",(0,s.jsx)(n.p,{children:"Requests are calls the clients sends to the server expecting a single response to be returned."}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n  Client->>+Server: Request\n  Server->>-Client: Response"}),"\n",(0,s.jsxs)(n.p,{children:["Requests may have parameters associated to them using the ",(0,s.jsx)(n.code,{children:"params"})," property and a ",(0,s.jsx)(n.code,{children:"result"})," property representing the type of a successful response, as in the example below:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:users/exists': {\n    type: 'request',\n    description: 'An example request procedure with parameters and result'\n    params: {\n      type: 'string',\n      description: 'user ID',\n    },\n    result: { type: 'boolean' },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Requests may also not define any ",(0,s.jsx)(n.code,{children:"params"})," or ",(0,s.jsx)(n.code,{children:"result"}),", for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:request': {\n    type: 'request',\n    description: 'An example request procedure with no parameters and result',\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,s.jsx)(n.h3,{id:"streams",children:"Streams"}),"\n",(0,s.jsx)(n.p,{children:"A stream is a stateful procedure that maintains a connection between the client and server until either the client or server closes it, or an error happens."}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n  Client->>+Server: Request\n  Server--\x3e>Client: Message 1\n  Server--\x3e>Client: Message 2\n  Server--\x3e>Client: ... Message N\n  Server->>-Client: Response"}),"\n",(0,s.jsxs)(n.p,{children:["Like requests, streams can have optional parameters associated to them using the ",(0,s.jsx)(n.code,{children:"params"})," property and a ",(0,s.jsx)(n.code,{children:"result"})," property defining the type of data that is sent back from the server once the stream is ended."]}),"\n",(0,s.jsxs)(n.p,{children:["Stream definions must provide a ",(0,s.jsx)(n.code,{children:"receive"})," property that represents the type of data sent by the server while the client is connected to it."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:stream-numbers': {\n    type: 'stream',\n    description: 'An example stream procedure sending numbers',\n    params: {\n      type: 'number',\n      description: 'The number to start from',\n    },\n    receive: { type: 'number' },\n    result: {\n      type: 'object',\n      properties: {\n        sum: { type: 'number', description: 'The sum of all numbers sent' },\n      },\n      required: ['sum'],\n    },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,s.jsx)(n.h3,{id:"channels",children:"Channels"}),"\n",(0,s.jsx)(n.p,{children:"Similar to streams, channels are stateful procedures that maintain a connection between the client and server until explicitly closed by either side or an error occurs. Unlike streams, however, channels can be used for bidirectional communication."}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n  Client->>+Server: Request\n  Server--\x3e>Client: ... Server messages\n  Client--\x3e>Server: ... Client messages\n  Server->>-Client: Response"}),"\n",(0,s.jsxs)(n.p,{children:["Like requests and streams, channels can have optional parameters associated to them using the ",(0,s.jsx)(n.code,{children:"params"})," property and a ",(0,s.jsx)(n.code,{children:"result"})," property defining the type of data that is sent back from the server once the channel is closed by the server."]}),"\n",(0,s.jsxs)(n.p,{children:["Similar to stream definions, channel definitions must provide a ",(0,s.jsx)(n.code,{children:"receive"})," property that represents the type of data sent by the server while the client is connected to it."]}),"\n",(0,s.jsxs)(n.p,{children:["Channel definitions must also provide the ",(0,s.jsx)(n.code,{children:"send"})," property which defines the type of data that can be sent from the client to the server."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:live-presence': {\n    type: 'channel',\n    description: 'An example channel procedure tracking present users',\n    params: {\n      type: 'object',\n      properties: {\n        room_id: { type: 'string', description: 'The ID of the room' },\n        active_time: { type: 'integer' },\n      },\n      required: ['room_id'],\n    },\n    send: { type: 'boolean', description: 'Toggle presence in the room' },\n    receive: { type: 'number', description: 'Number of users in the room' },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,s.jsx)(n.p,{children:"Using channels, it is possible to create sub-protocols such as allowing the server to make requests to the client instead of the client making requests to the server.\nThe relation between messages being sent and received in a channel is fully up to the client and server logic."}),"\n",(0,s.jsx)(n.h2,{id:"handling-procedures",children:"Handling procedures"}),"\n",(0,s.jsx)(n.p,{children:"Handling procedures on the server side is done by defining a mapping of procedure names to handler functions."}),"\n",(0,s.jsxs)(n.p,{children:["Handler functions are called with a single argument, which is an object containing the ",(0,s.jsx)(n.code,{children:"message"})," object received by the server."]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to the ",(0,s.jsx)(n.code,{children:"message"})," object, the following properties will be present based on the type of procedure:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data"})," for event procedures having defined a ",(0,s.jsx)(n.code,{children:"data"})," property, an object containing the data passed by the client."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"signal"})," for all cancellable (non-event) procedures, an ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:"AbortSignal"})," triggered when the client cancels the procedure."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"params"})," for all non-event procedures having defined a ",(0,s.jsx)(n.code,{children:"params"})," property, an object containing the parameters passed by the client."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"writer"})," for all stream and channel procedures, a ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WritableStreamDefaultWriter",children:(0,s.jsx)(n.code,{children:"WritableStreamDefaultWriter"})})," used to write data back to the client matching the ",(0,s.jsx)(n.code,{children:"receive"})," property of the procedure definition."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reader"})," for all channel procedures, a ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WritableStreamDefaultReader",children:(0,s.jsx)(n.code,{children:"WritableStreamDefaultReader"})})," used to read data sent by the client matching the ",(0,s.jsx)(n.code,{children:"send"})," property of the procedure definition."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Handler functions for non-event procedures should return a value or promise according to the ",(0,s.jsx)(n.code,{children:"result"})," property of the procedure definition, which will be sent back to the client."]}),"\n",(0,s.jsx)(n.h3,{id:"defining-handlers",children:"Defining handlers"}),"\n",(0,s.jsxs)(n.p,{children:["Handlers can be attached to a server using the ",(0,s.jsxs)(n.a,{href:"/docs/api/server/#serve",children:[(0,s.jsx)(n.code,{children:"serve()"})," function from the ",(0,s.jsx)(n.code,{children:"@enkaku/server"})," package"]}),", for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\nimport { serve } from '@enkaku/server'\n\nconst protocol = {\n  'myapp:users/exists': {\n    type: 'request',\n    description: 'An example request procedure with parameters and result'\n    params: {\n      type: 'string',\n      description: 'user ID',\n    },\n    result: { type: 'boolean' },\n  },\n} as const satisfies ProtocolDefinition\n\nserve({\n  // ... other parameters omitted for brevity\n  protocol,\n  handlers: {\n    'myapp:users/exists': async (ctx) => {\n      // Get the user ID, defined as string in the protocol definition\n      const id = ctx.params \n      // Return the result matching the protocol definition\n      return await myDB.users.exists(id)\n    }\n  }\n})\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cancellations",children:"Cancellations"}),"\n",(0,s.jsxs)(n.p,{children:["The context object passed to handlers for cancellable (non-event) procedures contains a ",(0,s.jsx)(n.code,{children:"signal"})," property triggered when the client aborts the procedure, for example to cancel a request or stop the execution of a stream or channel. The signal is an instance of ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:(0,s.jsx)(n.code,{children:"AbortSignal"})}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The following example presents a stream procedure handling the interruption of the procedure by the client:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\nimport { serve } from '@enkaku/server'\n\nconst protocol = {\n  'myapp:stream-numbers': {\n    type: 'stream',\n    description: 'An example stream procedure sending numbers',\n    params: {\n      type: 'number',\n      description: 'The number to start from',\n    },\n    receive: { type: 'number' },\n    result: {\n      type: 'object',\n      properties: {\n        sum: { type: 'number', description: 'The sum of all numbers sent' },\n      },\n      required: ['sum'],\n    },\n  },\n} as const satisfies ProtocolDefinition\n\nserve({\n  // ... other parameters omitted for brevity\n  protocol,\n  handlers: {\n    'myapp:stream-numbers': async (ctx) => {\n      // Get the first number from the client\n      let value = ctx.params\n      let sum = value\n      // Execute as long as the client does not close the stream\n      while (!ctx.signal.aborted) {\n        // Get the next number somehow\n        value = await getNextNumber(value)\n        if (value == null) {\n          // No more values - return the sum as result\n          return sum\n        }\n        // Add the new value to the sum\n        sum += value\n        // Write the next number to the stream\n        ctx.writer.write(value)\n      }\n      \n    }\n  }\n})\n"})}),"\n",(0,s.jsx)(n.h2,{id:"invoking-procedures",children:"Invoking procedures"}),"\n",(0,s.jsxs)(n.p,{children:["The easiest way to invoke procedures is to create a client by using the ",(0,s.jsxs)(n.a,{href:"/docs/api/client/",children:[(0,s.jsx)(n.code,{children:"@enkaku/client"})," package"]}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The client exposes the following methods to invoke procedures:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/api/client/#sendevent",children:(0,s.jsx)(n.code,{children:"sendEvent()"})})," to send an ",(0,s.jsx)(n.a,{href:"#events",children:(0,s.jsx)(n.code,{children:"event"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/api/client/#request",children:(0,s.jsx)(n.code,{children:"request()"})})," to send a ",(0,s.jsx)(n.a,{href:"#requests",children:(0,s.jsx)(n.code,{children:"request"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/api/client/#createstream",children:(0,s.jsx)(n.code,{children:"createStream()"})})," to create a ",(0,s.jsx)(n.a,{href:"#streams",children:(0,s.jsx)(n.code,{children:"stream"})}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/api/client/#createchannel",children:(0,s.jsx)(n.code,{children:"createChannel()"})})," to create a ",(0,s.jsx)(n.a,{href:"#channels",children:(0,s.jsx)(n.code,{children:"channel"})}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["All these methods return a ",(0,s.jsx)(n.code,{children:"Promise"})," that resolves when the message is ",(0,s.jsx)(n.strong,{children:"successfully written"})," to the transport, or rejects if the message cannot be sent."]}),"\n",(0,s.jsx)(n.h3,{id:"procedure-call-state",children:"Procedure call state"}),"\n",(0,s.jsxs)(n.p,{children:["While the ",(0,s.jsx)(n.code,{children:"sendEvent()"})," method returns a ",(0,s.jsx)(n.code,{children:"Promise<void>"})," as no further interaction is expected, the other three methods synchronously return a ",(0,s.jsxs)(n.a,{href:"/docs/api/client/#procedurecallresultvalue-return",children:[(0,s.jsx)(n.code,{children:"ProcedureCall"})," object"]})," containing the following properties:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"result"}),": a ",(0,s.jsx)(n.code,{children:"Promise"})," or a ",(0,s.jsxs)(n.a,{href:"https://github.com/everweij/typescript-result?tab=readme-ov-file#result",children:[(0,s.jsx)(n.code,{children:"Result"})," type from the ",(0,s.jsx)(n.code,{children:"typescript-result"})," package"]})," containing the result of the procedure call or error."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"toValue()"}),": a ",(0,s.jsx)(n.code,{children:"Promise"})," of the result value of the procedure call, or throwing an error if the call fails."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to the properties above, the ",(0,s.jsx)(n.code,{children:"ProcedureCall"})," object is itself a ",(0,s.jsx)(n.code,{children:"Promise"})," resolving to an object with the following values:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"abort()"}),": function to call to abort the procedure call."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id"}),": unique identifier of the procedure call."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"result"}),": a ",(0,s.jsx)(n.code,{children:"Promise"})," or a ",(0,s.jsxs)(n.a,{href:"https://github.com/everweij/typescript-result?tab=readme-ov-file#result",children:[(0,s.jsx)(n.code,{children:"Result"})," type from the ",(0,s.jsx)(n.code,{children:"typescript-result"})," package"]})," containing the result of the procedure call or error."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["When calling the ",(0,s.jsx)(n.code,{children:"createStream()"})," or ",(0,s.jsx)(n.code,{children:"createChannel()"})," method, the object returned by the ",(0,s.jsx)(n.code,{children:"Promise"})," also contain a ",(0,s.jsx)(n.code,{children:"receive"})," property being a ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream",children:(0,s.jsx)(n.code,{children:"ReadableStream"})})," containing the stream data sent by the server.\nA ",(0,s.jsx)(n.code,{children:"send(data): Promise<void>"})," function is also present to send data to the server when using the ",(0,s.jsx)(n.code,{children:"createChannel()"})," method."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { Client } from '@enkaku/client'\n\nconst client = new Client({\n  // ... params omitted for brevity\n})\n\nconst request = client.request('example:request')\n\nconst valuePromise = request.toValue() // Promise resolving to the result value or rejecting with an error\nconst resultPromise = request.result // Promise of a Result object\n\nconst requestState = await request // state object available after the message has been written to the transport\nconst requestID = requestState.id // unique ID for this request\n\nrequestState.abort() // aborts the request if it hasn't already completed\n\nconst sameResultPromise = requestState.result // same as request.result \n"})})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},6537:function(e,n,r){r.d(n,{Z:function(){return a},a:function(){return i}});var t=r(2379);let s={},o=t.createContext(s);function i(e){let n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);