"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["2807"],{7266:function(e,n,r){r.r(n),r.d(n,{default:()=>h,frontMatter:()=>o,metadata:()=>s,assets:()=>a,toc:()=>l,contentTitle:()=>c});var s=JSON.parse('{"id":"procedures","title":"Procedures","description":"Procedures are functions handled by a server that can be called by clients.","source":"@site/docs/procedures.mdx","sourceDirName":".","slug":"/procedures","permalink":"/docs/procedures","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Quick start","permalink":"/docs/quick-start"},"next":{"title":"Communications","permalink":"/docs/communications"}}'),t=r("5367"),i=r("8250");let o={},c="Procedures",a={},l=[{value:"Defining procedures",id:"defining-procedures",level:2},{value:"Events",id:"events",level:3},{value:"Requests",id:"requests",level:3},{value:"Streams",id:"streams",level:3},{value:"Channels",id:"channels",level:3},{value:"Handling procedures",id:"handling-procedures",level:2},{value:"Defining handlers",id:"defining-handlers",level:3},{value:"Cancellations",id:"cancellations",level:3},{value:"Invoking procedures",id:"invoking-procedures",level:2},{value:"Sending events",id:"sending-events",level:3},{value:"Sending requests",id:"sending-requests",level:3},{value:"Creating streams",id:"creating-streams",level:3},{value:"Creating channels",id:"creating-channels",level:3}];function d(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"procedures",children:"Procedures"})}),"\n",(0,t.jsx)(n.p,{children:"Procedures are functions handled by a server that can be called by clients."}),"\n",(0,t.jsx)(n.h2,{id:"defining-procedures",children:"Defining procedures"}),"\n",(0,t.jsxs)(n.p,{children:["Enkaku supports the following four types of procedures: ",(0,t.jsx)(n.a,{href:"#events",children:"events"}),", ",(0,t.jsx)(n.a,{href:"#requests",children:"requests"}),", ",(0,t.jsx)(n.a,{href:"#streams",children:"streams"})," and ",(0,t.jsx)(n.a,{href:"#channels",children:"channels"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Events and requests calls are supported by staless handlers, while streams and channels require stateful handlers to support sending messages from the server to the client."}),"\n",(0,t.jsxs)(n.p,{children:["Defining procedures involves creating a protocol for the client and server, typically using the ",(0,t.jsx)(n.code,{children:"ProtocolDefinition"})," type from the ",(0,t.jsx)(n.code,{children:"@enkaku/protocol"})," package."]}),"\n",(0,t.jsxs)(n.p,{children:["A protocol is defined as a record of procedure names to procedure definitions. Each procedure definition must include the type of procedure (",(0,t.jsx)(n.code,{children:"event"}),", ",(0,t.jsx)(n.code,{children:"request"}),", ",(0,t.jsx)(n.code,{children:"stream"})," or ",(0,t.jsx)(n.code,{children:"channel"}),"), an optional ",(0,t.jsx)(n.code,{children:"description"})," for documentation purposes, and any additional data types required by the procedure."]}),"\n",(0,t.jsx)(n.p,{children:"Procedure names have no particular constraints other than being unique strings within the protocol or set of protocols used on a given transport."}),"\n",(0,t.jsx)(n.p,{children:"Example protocol definition:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nexport const myProtocol = {\n  'myapp:event': {\n    type: 'event',\n    description: 'An example event procedure with no data',\n  },\n  'myapp:request': {\n    type: 'request',\n    description: 'An example request procedure that returns a string',\n    response: { type: 'string' },\n  },\n  'myapp:stream': {\n    type: 'stream',\n    description: 'An example stream procedure that returns a stream of numbers',\n    receive: { type: 'number' },\n  },\n  'myapp:channel': {\n    type: 'channel',\n    description: 'An example channel procedure that sends and receives numbers',\n    send: { type: 'number' },\n    receive: { type: 'number' },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,t.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,t.jsx)(n.p,{children:'Events are simple "fire and forget" calls that the client sends to the server without expecting a response.'}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n  Client->>+Server: Event"}),"\n",(0,t.jsxs)(n.p,{children:["To define an event procedure in Enkaku, the ",(0,t.jsx)(n.code,{children:"type"})," must be set to ",(0,t.jsx)(n.code,{children:"event"}),", for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:event': {\n    type: 'event',\n    description: 'An example event procedure with no data',\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,t.jsx)(n.p,{children:"Events can also have a data object attached to them, which must be defined as a JSON schema in the protocol:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'my:event': {\n    type: 'event',\n    description: 'An example event procedure with data',\n    data: {\n      type: 'object',\n      properties: {\n        value: { type: 'number' },\n      },\n    },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,t.jsx)(n.h3,{id:"requests",children:"Requests"}),"\n",(0,t.jsx)(n.p,{children:"Requests are calls the clients sends to the server expecting a single response to be returned."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n  Client->>+Server: Request\n  Server->>-Client: Response"}),"\n",(0,t.jsxs)(n.p,{children:["Requests may have parameters associated to them using the ",(0,t.jsx)(n.code,{children:"param"})," property and a ",(0,t.jsx)(n.code,{children:"result"})," property representing the type of a successful response, as in the example below:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:users/exists': {\n    type: 'request',\n    description: 'An example request procedure with parameters and result'\n    param: {\n      type: 'string',\n      description: 'user ID',\n    },\n    result: { type: 'boolean' },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Requests may also not define any ",(0,t.jsx)(n.code,{children:"param"})," or ",(0,t.jsx)(n.code,{children:"result"}),", for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:request': {\n    type: 'request',\n    description: 'An example request procedure with no parameters and result',\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,t.jsx)(n.h3,{id:"streams",children:"Streams"}),"\n",(0,t.jsx)(n.p,{children:"A stream is a stateful procedure that maintains a connection between the client and server until either the client or server closes it, or an error happens."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n  Client->>+Server: Request\n  Server--\x3e>Client: Message 1\n  Server--\x3e>Client: Message 2\n  Server--\x3e>Client: ... Message N\n  Server->>-Client: Response"}),"\n",(0,t.jsxs)(n.p,{children:["Like requests, streams can have optional parameters associated to them using the ",(0,t.jsx)(n.code,{children:"param"})," property and a ",(0,t.jsx)(n.code,{children:"result"})," property defining the type of data that is sent back from the server once the stream is ended."]}),"\n",(0,t.jsxs)(n.p,{children:["Stream definions must provide a ",(0,t.jsx)(n.code,{children:"receive"})," property that represents the type of data sent by the server while the client is connected to it."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:stream-numbers': {\n    type: 'stream',\n    description: 'An example stream procedure sending numbers',\n    param: {\n      type: 'number',\n      description: 'The number to start from',\n    },\n    receive: { type: 'number' },\n    result: {\n      type: 'object',\n      properties: {\n        sum: { type: 'number', description: 'The sum of all numbers sent' },\n      },\n      required: ['sum'],\n    },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,t.jsx)(n.h3,{id:"channels",children:"Channels"}),"\n",(0,t.jsx)(n.p,{children:"Similar to streams, channels are stateful procedures that maintain a connection between the client and server until explicitly closed by either side or an error occurs. Unlike streams, however, channels can be used for bidirectional communication."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n  Client->>+Server: Request\n  Server--\x3e>Client: ... Server messages\n  Client--\x3e>Server: ... Client messages\n  Server->>-Client: Response"}),"\n",(0,t.jsxs)(n.p,{children:["Like requests and streams, channels can have optional parameters associated to them using the ",(0,t.jsx)(n.code,{children:"param"})," property and a ",(0,t.jsx)(n.code,{children:"result"})," property defining the type of data that is sent back from the server once the channel is closed by the server."]}),"\n",(0,t.jsxs)(n.p,{children:["Similar to stream definions, channel definitions must provide a ",(0,t.jsx)(n.code,{children:"receive"})," property that represents the type of data sent by the server while the client is connected to it."]}),"\n",(0,t.jsxs)(n.p,{children:["Channel definitions must also provide the ",(0,t.jsx)(n.code,{children:"send"})," property which defines the type of data that can be sent from the client to the server."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\n\nconst protocol = {\n  'myapp:live-presence': {\n    type: 'channel',\n    description: 'An example channel procedure tracking present users',\n    param: {\n      type: 'object',\n      properties: {\n        room_id: { type: 'string', description: 'The ID of the room' },\n        active_time: { type: 'integer' },\n      },\n      required: ['room_id'],\n    },\n    send: { type: 'boolean', description: 'Toggle presence in the room' },\n    receive: { type: 'number', description: 'Number of users in the room' },\n  },\n} as const satisfies ProtocolDefinition\n"})}),"\n",(0,t.jsx)(n.p,{children:"Using channels, it is possible to create sub-protocols such as allowing the server to make requests to the client instead of the client making requests to the server.\nThe relation between messages being sent and received in a channel is fully up to the client and server logic."}),"\n",(0,t.jsx)(n.h2,{id:"handling-procedures",children:"Handling procedures"}),"\n",(0,t.jsx)(n.p,{children:"Handling procedures on the server side is done by defining a mapping of procedure names to handler functions."}),"\n",(0,t.jsxs)(n.p,{children:["Handler functions are called with a single argument, which is an object containing the ",(0,t.jsx)(n.code,{children:"message"})," object received by the server."]}),"\n",(0,t.jsxs)(n.p,{children:["In addition to the ",(0,t.jsx)(n.code,{children:"message"})," object, the following properties will be present based on the type of procedure:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"})," for event procedures having defined a ",(0,t.jsx)(n.code,{children:"data"})," property, an object containing the data passed by the client."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"signal"})," for all cancellable (non-event) procedures, an ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:"AbortSignal"})," triggered when the client cancels the procedure."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"param"})," for all non-event procedures having defined a ",(0,t.jsx)(n.code,{children:"param"})," property, an object containing the parameters passed by the client."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"writable"})," for all stream and channel procedures, a ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WritableStream",children:(0,t.jsx)(n.code,{children:"WritableStream"})})," used to write data back to the client matching the ",(0,t.jsx)(n.code,{children:"receive"})," property of the procedure definition."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"readable"})," for all channel procedures, a ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream",children:(0,t.jsx)(n.code,{children:"ReadableStream"})})," used to read data sent by the client matching the ",(0,t.jsx)(n.code,{children:"send"})," property of the procedure definition."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Handler functions for non-event procedures should return a value or promise according to the ",(0,t.jsx)(n.code,{children:"result"})," property of the procedure definition, which will be sent back to the client."]}),"\n",(0,t.jsx)(n.h3,{id:"defining-handlers",children:"Defining handlers"}),"\n",(0,t.jsxs)(n.p,{children:["Handlers can be attached to a server using the ",(0,t.jsxs)(n.a,{href:"/docs/api/server/#serve",children:[(0,t.jsx)(n.code,{children:"serve()"})," function from the ",(0,t.jsx)(n.code,{children:"@enkaku/server"})," package"]}),", for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\nimport { serve } from '@enkaku/server'\n\nconst protocol = {\n  'myapp:users/exists': {\n    type: 'request',\n    description: 'An example request procedure with parameters and result'\n    param: {\n      type: 'string',\n      description: 'user ID',\n    },\n    result: { type: 'boolean' },\n  },\n} as const satisfies ProtocolDefinition\n\nserve({\n  // ... other parameters omitted for brevity\n  protocol,\n  handlers: {\n    'myapp:users/exists': async (ctx) => {\n      // Get the user ID, defined as string in the protocol definition\n      const id = ctx.param\n      // Return the result matching the protocol definition\n      return await myDB.users.exists(id)\n    }\n  }\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cancellations",children:"Cancellations"}),"\n",(0,t.jsxs)(n.p,{children:["The context object passed to handlers for cancellable (non-event) procedures contains a ",(0,t.jsx)(n.code,{children:"signal"})," property triggered when the client aborts the procedure, for example to cancel a request or stop the execution of a stream or channel. The signal is an instance of ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal",children:(0,t.jsx)(n.code,{children:"AbortSignal"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The following example presents a stream procedure handling the interruption of the procedure by the client:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import type { ProtocolDefinition } from '@enkaku/protocol'\nimport { serve } from '@enkaku/server'\n\nconst protocol = {\n  'myapp:stream-numbers': {\n    type: 'stream',\n    description: 'An example stream procedure sending numbers',\n    param: {\n      type: 'number',\n      description: 'The number to start from',\n    },\n    receive: { type: 'number' },\n    result: {\n      type: 'object',\n      properties: {\n        sum: { type: 'number', description: 'The sum of all numbers sent' },\n      },\n      required: ['sum'],\n    },\n  },\n} as const satisfies ProtocolDefinition\n\nserve({\n  // ... other parameters omitted for brevity\n  protocol,\n  handlers: {\n    'myapp:stream-numbers': async (ctx) => {\n      const writer = ctx.writable.getWriter()\n      // Get the first number from the client\n      let value = ctx.param\n      let sum = value\n      // Execute as long as the client does not close the stream\n      while (!ctx.signal.aborted) {\n        // Get the next number somehow\n        value = await getNextNumber(value)\n        if (value == null) {\n          // No more values - return the sum as result\n          return sum\n        }\n        // Add the new value to the sum\n        sum += value\n        // Write the next number to the stream\n        writer.write(value)\n      }\n      \n    }\n  }\n})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"invoking-procedures",children:"Invoking procedures"}),"\n",(0,t.jsxs)(n.p,{children:["The easiest way to invoke procedures is to create a client by using the ",(0,t.jsxs)(n.a,{href:"/docs/api/client/",children:[(0,t.jsx)(n.code,{children:"@enkaku/client"})," package"]}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The client exposes the following methods to invoke procedures:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/api/client/#sendevent",children:(0,t.jsx)(n.code,{children:"sendEvent()"})})," to send an ",(0,t.jsx)(n.a,{href:"#events",children:(0,t.jsx)(n.code,{children:"event"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/api/client/#request",children:(0,t.jsx)(n.code,{children:"request()"})})," to send a ",(0,t.jsx)(n.a,{href:"#requests",children:(0,t.jsx)(n.code,{children:"request"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/api/client/#createstream",children:(0,t.jsx)(n.code,{children:"createStream()"})})," to create a ",(0,t.jsx)(n.a,{href:"#streams",children:(0,t.jsx)(n.code,{children:"stream"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/api/client/#createchannel",children:(0,t.jsx)(n.code,{children:"createChannel()"})})," to create a ",(0,t.jsx)(n.a,{href:"#channels",children:(0,t.jsx)(n.code,{children:"channel"})}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"sending-events",children:"Sending events"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"#events",children:"Events"})," can be sent using the ",(0,t.jsxs)(n.a,{href:"/docs/api/client/#sendevent",children:[(0,t.jsx)(n.code,{children:"sendEvent()"})," method"]})," of the client, which returns as ",(0,t.jsx)(n.code,{children:"Promise<void>"})," resolving when successfully writing to the transport."]}),"\n",(0,t.jsx)(n.h3,{id:"sending-requests",children:"Sending requests"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"#requests",children:"Requests"})," can be sent using the ",(0,t.jsxs)(n.a,{href:"/docs/api/client/#request",children:[(0,t.jsx)(n.code,{children:"request()"})," method"]})," of the client, which returns as ",(0,t.jsx)(n.code,{children:"Promise<Result>"})," resolving the ",(0,t.jsx)(n.code,{children:"Result"})," sent by the server. The returned ",(0,t.jsx)(n.code,{children:"Promise"})," is augmented with the following properties:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"abort: (reason?: string) => void"}),": abort the call, rejecting the promise with an ",(0,t.jsx)(n.code,{children:"AbortSignal"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"signal: AbortSignal"}),": abort signal for the call"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"creating-streams",children:"Creating streams"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"#streams",children:"Streams"})," can be sent using the ",(0,t.jsxs)(n.a,{href:"/docs/api/client/#createstream",children:[(0,t.jsx)(n.code,{children:"createStream()"})," method"]})," of the client, which returns as ",(0,t.jsx)(n.code,{children:"Promise<Result>"})," resolving the ",(0,t.jsx)(n.code,{children:"Result"})," sent by the server once the stream is closed. The returned ",(0,t.jsx)(n.code,{children:"Promise"})," is augmented with the following properties:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"abort: (reason?: string) => void"}),": abort the call, rejecting the promise with an ",(0,t.jsx)(n.code,{children:"AbortSignal"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"close: () => void"}),": abort the call with the ",(0,t.jsx)(n.code,{children:"Close"})," reason, allowing the server to still send a ",(0,t.jsx)(n.code,{children:"Result"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"signal: AbortSignal"}),": abort signal for the call"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"readable: ReadableStream<Receive>"}),": ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream",children:(0,t.jsx)(n.code,{children:"ReadableStream"})})," of ",(0,t.jsx)(n.code,{children:"Receive"})," values sent by the server"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"creating-channels",children:"Creating channels"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"#channels",children:"Channels"})," can be sent using the ",(0,t.jsxs)(n.a,{href:"/docs/api/client/#createchannel",children:[(0,t.jsx)(n.code,{children:"createChannel()"})," method"]})," of the client, which returns as ",(0,t.jsx)(n.code,{children:"Promise<Result>"})," resolving the ",(0,t.jsx)(n.code,{children:"Result"})," sent by the server once the channel is closed. The returned ",(0,t.jsx)(n.code,{children:"Promise"})," is augmented with the following properties:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"abort: (reason?: string) => void"}),": abort the call, rejecting the promise with an ",(0,t.jsx)(n.code,{children:"AbortSignal"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"close: () => void"}),": abort the call with the ",(0,t.jsx)(n.code,{children:"Close"})," reason, allowing the server to still send a ",(0,t.jsx)(n.code,{children:"Result"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"signal: AbortSignal"}),": abort signal for the call"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"readable: ReadableStream<Receive>"}),": ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream",children:(0,t.jsx)(n.code,{children:"ReadableStream"})})," of ",(0,t.jsx)(n.code,{children:"Receive"})," values sent by the server"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"writable: WritableStream<Receive>"}),": ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WritableStream",children:(0,t.jsx)(n.code,{children:"WritableStream"})})," of ",(0,t.jsx)(n.code,{children:"Send"})," values sent by the client"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"send: (value: Send) => Promise<void>"}),": send a ",(0,t.jsx)(n.code,{children:"Send"})," value to the server"]}),"\n"]})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8250:function(e,n,r){r.d(n,{Z:function(){return c},a:function(){return o}});var s=r(3800);let t={},i=s.createContext(t);function o(e){let n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);